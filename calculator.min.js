"use strict";var ASTER,ASTERLang,DecoratorFactory,ASTERUtils,__esDecorate=this&&this.__esDecorate||function(e,t,r,n,a,s){function o(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var i,u=n.kind,c="getter"===u?"get":"setter"===u?"set":"value",l=!t&&e?n.static?e:e.prototype:null,g=t||(l?Object.getOwnPropertyDescriptor(l,n.name):{}),p=!1,h=r.length-1;h>=0;h--){var d={};for(var f in n)d[f]="access"===f?{}:n[f];for(var f in n.access)d.access[f]=n.access[f];d.addInitializer=function(e){if(p)throw new TypeError("Cannot add initializers after decoration has completed");s.push(o(e||null))};var m=(0,r[h])("accessor"===u?{get:g.get,set:g.set}:g[c],d);if("accessor"===u){if(void 0===m)continue;if(null===m||"object"!=typeof m)throw new TypeError("Object expected");(i=o(m.get))&&(g.get=i),(i=o(m.set))&&(g.set=i),(i=o(m.init))&&a.unshift(i)}else(i=o(m))&&("field"===u?a.unshift(i):g[c]=i)}l&&Object.defineProperty(l,n.name,g),p=!0},__runInitializers=this&&this.__runInitializers||function(e,t,r){for(var n=arguments.length>2,a=0;a<t.length;a++)r=n?t[a].call(e,r):t[a].call(e);return n?r:void 0};Object.defineProperty(exports,"__esModule",{value:!0}),function(e){let t,r;!function(e){e.splitGraphemes=function(e){return Array.from(new Intl.Segmenter("en",{granularity:"grapheme"}).segment(e),(({segment:e})=>e))}}(t||(t={}));class n{name;position;tags;properties;children;constructor(e,t,{tags:r=[],props:n={},children:a}={}){this.name=e,this.position=t,this.tags="string"==typeof r?r.split(/,|\s+/g).filter((e=>e)):[...r],n instanceof Map?this.properties=n:this.properties=new Map(Object.entries(n)),this.children=a}getName(){return this.name}hasTag(e){return this.tags.includes(e)}hasProp(e){return this.properties.has(e)}getProp(e){return this.properties.get(e)}hasChildren(){return!!this.children?.length}getChildren(){return this.hasChildren()?[...this.children]:[]}getStart(){return this.position.start}getLength(){return this.position.length}getRawValue(){return this.children?.map((e=>e.getRawValue())).join("")??""}}e.Token=n;class a extends n{value;constructor(e,t,{tags:r,props:n}={}){super("CHAR",t,{tags:r,props:n}),this.value=e}getValue(){return this.value}getRawValue(){return this.getValue()}}e.CharToken=a;class s extends n{constructor(e,t,{tags:r,props:n}={}){super(e,t,{tags:r,props:n})}getRawValue(){return""}}e.tokenize=function(e,t){const r=[new s("SOF",{start:-1,length:0}),...[...e].map(((e,t)=>new a(e,{start:t,length:e.length}))),new s("EOF",{start:e.length,length:0})];function o(e){let t=!1;for(let a=0;a<r.length;a++){const s=new Map,o=e.pattern.matches(r.slice(a),s,r.slice(0,a));if(-1!==o){const i=r.slice(a,a+o),u={start:(i[0]??r[a]).getStart(),length:i.reduce(((e,t)=>e+t.getLength()),0)},c="string"==typeof e.result?new n(e.result,u,{children:i,props:s}):e.result(i,u,s);r.splice(a,o,...Array.isArray(c)?c:[c]),t||=!0,a--}}return t}for(const e of t)o(e);const i=t.filter((e=>e.recursive));let u;do{u=!1;for(const e of i)u||=o(e)}while(u);return r},function(t){function r(e){return 1-2*+!e}function n(e,{min:t=1,max:r=-1}={}){return{matches(n,a,s){let o=0,i=0;for(;-1===r||o<=r;){const t=e.matches(n.slice(i),a,[...s,...n.slice(0,i)]);if(-1===t)break;i+=t,o++}return o>=t?i:0===t?0:-1}}}t.tk=function(e){return{matches:([t])=>r(t&&t.getName()===e)}},t.char=function(e){return{matches:([t])=>r(t instanceof a&&t.getValue()===e)}},t.str=function(t){return{matches(r){for(let n=0;n<t.length;n++){const a=r[n];if(!(a instanceof e.CharToken)||a.getValue()!==t[n])return-1}return t.length}}},t.capture=function(e,t){return{matches(r,n,a){const s=t.matches(r,n,a);return-1!==s?n.set(e,r.slice(0,s)):n.set(e,null),s}}},t.wildchar=function(e="*"){return{matches:function(){switch(e){case"*":return([e])=>r(e instanceof a);case"~":return([e])=>r(e instanceof a&&/^\s$/.test(e?.getValue?.()));case"$":return([e])=>r(e instanceof a&&/\d$/.test(e?.getValue?.()));default:throw"NYI"}}()}},t.seq=function(...e){return{matches(t,r,n){let a=0;for(let s=0;s<e.length;s++){const o=e[s].matches(t.slice(a),r,[...n,...t.slice(0,a)]);if(-1===o)return-1;a+=o}return a}}},t.count=n,t.any=function(e){return n(e,{min:0})},t.optional=function(e){return n(e,{min:0,max:1})},t.or=function(...e){return{matches(t,r,n){for(const a of e){const e=a.matches(t,r,n);if(-1!==e)return e}return-1}}},t.not=function(e){return{matches([t],r,n){if(!t)return-1;const a=e.matches([t],r,n);return-1*a+-1*+!a}}},t.hasprop=function(e){return{matches:([t])=>r(t?.hasProp?.(e))}},t.propeq=function(e,t){return{matches:([n])=>r(n?.hasProp?.(e)&&n?.getProp?.(e)===t)}},t.is=function(e){return{matches:([t])=>r(t?.hasTag?.(e))}},t.and=function(...e){return{matches:(t,r,n)=>Math.min(...e.map((e=>e.matches(t,r,n))))}},t.re=function(e,{ignoreCase:t=!1}={}){return{matches(r,n,s){let o="";for(const e of r){if(!(e instanceof a))break;o+=e.getValue()}let i=0;for(const e of s.reverse()){if(!(e instanceof a))break;o=e.getValue()+o,i++}const u=new RegExp(e,"gud"+"i".repeat(+t));u.lastIndex=i;const c=u.exec(o);return c?.indices?.[0]?.[0]===i?(Object.entries(c.groups??{}).forEach((([e,t])=>n.set(e,[...t].map((t=>new a(t,{start:r[0].getStart()+c.indices.groups[e][0],length:1})))))),u.lastIndex-i):-1}}},t.lambda=function(e){return{matches:([t])=>r(e(t))}},t.next=function(e){return{matches:(t,r,n)=>e.matches(t,r,n)>=0?0:-1}},t.prev=function(e){return{matches:(t,r,n)=>e.matches(n.reverse(),r,[])>=0?0:-1}}}(r=e.PatternBuilders||(e.PatternBuilders={}))}(ASTER||(ASTER={})),function(e){const{seq:t,char:r,capture:n,wildchar:a,count:s,tk:o,or:i,and:u,prev:c,next:l,not:g,hasprop:p,propeq:h,re:d,is:f,lambda:m,any:v,optional:w}=ASTER.PatternBuilders,R=d(String.raw`(?:[a-z][a-z0-9_\-]*:)?[a-z][a-z0-9_\-]*`,{ignoreCase:!0});class x extends ASTER.Token{reducer;constructor(e,t,r,n){super(e,t,r),this.reducer=n}static of(e,t){return function(r,n,a){return new x(e,n,{children:r,props:a,tags:"logic"},t)}}reduce(){return this.reducer(this)}}class y extends ASTER.Token{constructor(e,t,r){super(e,t,r)}static of(e){return function(t,r,n){return new y(e,r,{children:t,props:n,tags:"escaped"})}}getRawValue(){return this.getChildren()[1].getRawValue()}}function P(e,t){const r=e.getProp(t);return{getRawValue:()=>r.map((e=>e?.getRawValue())).join("")??"",reduce:()=>r[0].reduce(),tokens:r}}const E=[{pattern:t(r("\\"),r('"')),result:y.of("asterlang:escaped-quote")},{pattern:t(r("\\"),r("/")),result:y.of("asterlang:escaped-slash")},{pattern:t(r("\\"),a("~")),result:y.of("asterlang:escaped-ws")},{pattern:t(r('"'),n("data",v(i(g(r('"')),f("escaped")))),r('"')),result:x.of("asterlang:string",(function(e){return ASTER.PatternBuilders.str(P(e,"data").getRawValue())}))},{pattern:t(r("/"),n("value",s(i(g(r("/")),f("escaped")))),r("/"),n("i",w(r("i")))),result:x.of("asterlang:re",(function(e){const t=e.getProp("value").map((function(e){return e instanceof y?"\\"+e.getRawValue():e.getRawValue()})).join("");return ASTER.PatternBuilders.re(t,{ignoreCase:"i"===P(e,"i").getRawValue()})}))},{pattern:a("~"),result:()=>[]},{pattern:f("escaped"),result:([e],t)=>[new ASTER.CharToken("\\",{start:t.start,length:1}),new ASTER.CharToken(e.getRawValue(),{start:t.length+1,length:1})]},{pattern:t(r("\\"),n("what",a())),result:x.of("asterlang:char",(function(e){return ASTER.PatternBuilders.char(P(e,"what").getRawValue())}))},{pattern:r("*"),result:x.of("asterlang:wildchar-any",(function(){return ASTER.PatternBuilders.wildchar("*")}))},{pattern:r("$"),result:x.of("asterlang:wildchar-digit",(function(){return ASTER.PatternBuilders.wildchar("$")}))},{pattern:r("~"),result:x.of("asterlang:wildchar-digit",(function(){return ASTER.PatternBuilders.wildchar("~")}))},{pattern:t(r("("),n("value",f("logic")),r(")")),result:x.of("asterlang:group",(function(e){return P(e,"value").reduce()})),recursive:!0},{pattern:t(n("value",f("logic")),r("+")),result:x.of("asterlang:any",(function(e){return ASTER.PatternBuilders.any(P(e,"value").reduce())})),recursive:!0},{pattern:t(n("value",f("logic")),r("?")),result:x.of("asterlang:optional",(function(e){return ASTER.PatternBuilders.optional(P(e,"value").reduce())})),recursive:!0},{pattern:t(n("value",f("logic")),n("min",v(a("$"))),r("."),r("."),n("max",v(a("$")))),result:x.of("asterlang:count",(function(e){const t=e=>Number.isNaN(e=+(e||NaN))?void 0:e,r=t(P(e,"min").getRawValue()),n=t(P(e,"min").getRawValue());return ASTER.PatternBuilders.count(P(e,"value").reduce(),{min:r,max:n})})),recursive:!0},{pattern:t(r("@"),n("what",R)),result:x.of("asterlang:tk",(function(e){return ASTER.PatternBuilders.tk(P(e,"what").getRawValue())}))},{pattern:t(r("#"),n("what",R)),result:x.of("asterlang:is",(function(e){return ASTER.PatternBuilders.is(P(e,"what").getRawValue())}))},{pattern:t(r("!"),n("value",f("logic"))),result:x.of("asterlang:not",(function(e){const t=P(e,"value").reduce();return ASTER.PatternBuilders.not({matches(...e){const r=t.matches(...e);if(r<-1||r>1)throw new SyntaxError("Only results of -1, 0, or 1 can be negated");return r}})})),recursive:!0},{pattern:t(n("lhs",f("logic")),r("|"),r("|"),n("rhs",f("logic"))),result:x.of("asterlang:or",(function(e){return ASTER.PatternBuilders.or(P(e,"lhs").reduce(),P(e,"rhs").reduce())})),recursive:!0},{pattern:t(n("lhs",f("logic")),r("&"),r("&"),n("rhs",f("logic"))),result:x.of("asterlang:and",(function(e){return ASTER.PatternBuilders.and(P(e,"lhs").reduce(),P(e,"rhs").reduce())})),recursive:!0},{pattern:t(r(">"),r(">"),n("value",f("logic"))),result:x.of("asterlang:next",(function(e){return ASTER.PatternBuilders.next(P(e,"value").reduce())})),recursive:!0},{pattern:t(r("<"),r("<"),n("value",f("logic"))),result:x.of("asterlang:prev",(function(e){return ASTER.PatternBuilders.prev(P(e,"value").reduce())})),recursive:!0},{pattern:t(r("["),n("what",R),r("="),n("value",i(o("asterlang:string"),s(a("$")))),r("]")),result:x.of("asterlang:propeq",(function(e){const t=P(e,"value");let r;return r="asterlang:string"===t.tokens[0].getName()?P(t.tokens[0],"data").getRawValue():+t.getRawValue(),ASTER.PatternBuilders.propeq(P(e,"what").getRawValue(),r)}))},{pattern:t(r("["),n("what",R),r("]")),result:x.of("asterlang:hasprop",(function(e){return ASTER.PatternBuilders.hasprop(P(e,"what").getRawValue())}))},{pattern:t(n("name",R),r(":"),n("value",f("logic"))),result:x.of("asterlang:capture",(function(e){return ASTER.PatternBuilders.capture(P(e,"name").getRawValue(),P(e,"value").reduce())})),recursive:!0},{pattern:t(f("logic"),s(f("logic"))),result:x.of("asterlang:seq",(function(e){return ASTER.PatternBuilders.seq(...e.getChildren().map((e=>e.reduce())))})),recursive:!0}];e.expr=function(e){const t=ASTER.tokenize(e,E);let r,n=0;function a(e){const a=t.shift();if(void 0===a)throw new Error(`Unexpected EOF at position ${n+(r?r.getLength():0)}`);if(e.matches([a],new Map,[])<0)throw new Error(`Unexpected token ${a.getName()} "${a.getRawValue()}" at position ${a.getStart()}.`);r=a,n=r.getStart()}a(o("SOF")),a(f("logic"));const s=r.reduce();return a(o("EOF")),s}}(ASTERLang||(ASTERLang={})),function(e){function t(...e){return!(("function"==typeof e[0]||void 0===e[0])&&(t=e[1],"object"==typeof t&&null!==t&&["kind","name"].every((e=>Object.hasOwn(t,e)))));var t}e.invokeDefault=function(e,t,...r){return"class"===t.kind?new e(...r):e(...r)},e.decorator=function(e){return function(...r){if(t(...r))return(t,n)=>e(t,n,...r);{const[t,n]=r;return e(t,n)}}}}(DecoratorFactory||(DecoratorFactory={})),function(e){const t=Symbol("asterConfig");function r(e,r){if("method"!==r.kind||"string"!=typeof r.name)throw new TypeError("AsterUtils annotations can only be used on class methods with string names");return e[t]??={name:r.name,tags:[],syntax:null,recursive:!1}}e.tags=DecoratorFactory.decorator(((e,t,n=[])=>{r(e,t).tags.push(...n.filter((e=>e)))})),e.tag=DecoratorFactory.decorator(((e,t,n,a)=>{const s=r(e,t);n&&(Array.isArray(n)?s.tags.push(String.raw(n,a)):s.tags.push(n))})),e.syntax=DecoratorFactory.decorator(((e,t,n,a)=>{const s=r(e,t);n&&(Array.isArray(n)?s.syntax=String.raw(n,a):s.syntax=n)})),e.recursive=DecoratorFactory.decorator(((e,t,n=!0)=>{r(e,t).recursive=n}));e.Parser=class{DynamicToken=class e extends ASTER.Token{reducer;constructor(e,t,r,n){super(e,t,r),this.reducer=n}static of(t,r,n){return function(a,s,o){return new e(t,s,{children:a,props:o,tags:r},n)}}reduce(e){return this.reducer(this,e)}};tokenizers;constructor(e){const r=Object.getPrototypeOf(e);this.tokenizers=Object.getOwnPropertyNames(r).filter((e=>"constructor"!==e&&!e.startsWith("_"))).flatMap((e=>{const n=Reflect.get(r[e],t);if(!n||!n.syntax)throw new Error(`Pattern ${e} needs a syntax configuration`);const a=ASTERLang.expr(n.syntax);if(-1!==a.matches([],new Map,[]))throw new Error(`Pattern for ${e} ('${n.syntax}') matches empty space`);return[{pattern:a,result:this.DynamicToken.of(n.name,n.tags,r[e]),recursive:n.recursive}]}))}parse(e,t){const r=ASTER.tokenize(e,this.tokenizers),[n,a,s]=r;return a.reduce(t)}}}(ASTERUtils||(ASTERUtils={}));const{syntax,tag,tags,recursive,Parser}=ASTERUtils,node_readline_1=require("node:readline");let CalculatorGrammar=(()=>{let e,t,r,n,a,s,o,i,u,c,l,g=[];return class{static{e=[syntax`/[a-z_]+/i`,tag`expr`,tag`negatable`],t=[syntax`$..\.$..`,tag`expr`,tag`negatable`],r=[syntax`$..`,tag`expr`,tag`negatable`],n=[syntax`<<(\* || \/ || \+ || \- || \^ || @SOF || \= || \( || \|) ~+ \- ~+ value: #negatable`,tag`expr`],a=[syntax`\( (value: #expr) \)`,tag`expr`,tag`negatable`,recursive],s=[syntax`(name: @variable) (arg: @group)`,tag`expr`,tag`negatable`,recursive],o=[syntax`\| (value: #expr) \|`,tag`expr`,tag`negatable`,recursive],i=[syntax`(lhs: #expr) ~+ \^ ~+ (rhs: #expr)`,tag`expr`,recursive],u=[syntax`(lhs: #expr) ~+ (op: \* || \/) ~+ (rhs: #expr)`,tag`expr`,recursive],c=[syntax`(lhs: #expr) ~+ (op: \+ || \-) ~+ (rhs: #expr)`,tag`expr`,recursive],l=[syntax`(name: @variable) ~+ \= ~+ (value: #expr)`,tag`expr`,recursive],__esDecorate(this,null,e,{kind:"method",name:"variable",static:!1,private:!1,access:{has:e=>"variable"in e,get:e=>e.variable}},null,g),__esDecorate(this,null,t,{kind:"method",name:"decimal",static:!1,private:!1,access:{has:e=>"decimal"in e,get:e=>e.decimal}},null,g),__esDecorate(this,null,r,{kind:"method",name:"int",static:!1,private:!1,access:{has:e=>"int"in e,get:e=>e.int}},null,g),__esDecorate(this,null,n,{kind:"method",name:"negative",static:!1,private:!1,access:{has:e=>"negative"in e,get:e=>e.negative}},null,g),__esDecorate(this,null,a,{kind:"method",name:"group",static:!1,private:!1,access:{has:e=>"group"in e,get:e=>e.group}},null,g),__esDecorate(this,null,s,{kind:"method",name:"func",static:!1,private:!1,access:{has:e=>"func"in e,get:e=>e.func}},null,g),__esDecorate(this,null,o,{kind:"method",name:"abs",static:!1,private:!1,access:{has:e=>"abs"in e,get:e=>e.abs}},null,g),__esDecorate(this,null,i,{kind:"method",name:"pow",static:!1,private:!1,access:{has:e=>"pow"in e,get:e=>e.pow}},null,g),__esDecorate(this,null,u,{kind:"method",name:"multdiv",static:!1,private:!1,access:{has:e=>"multdiv"in e,get:e=>e.multdiv}},null,g),__esDecorate(this,null,c,{kind:"method",name:"addsub",static:!1,private:!1,access:{has:e=>"addsub"in e,get:e=>e.addsub}},null,g),__esDecorate(this,null,l,{kind:"method",name:"assignment",static:!1,private:!1,access:{has:e=>"assignment"in e,get:e=>e.assignment}},null,g)}variable(e,t){const r=e.getRawValue().toLowerCase(),n=t.variables.get(r);if(null==n)throw new Error(`Variable '${r}' does not exist!`);return n}decimal(e,t){return+e.getRawValue()}int(e,t){return+e.getRawValue()}negative(e,t){return-e.getProp("value")[0].reduce(t)}group(e,t){return e.getProp("value")[0].reduce(t)}func(e,t){const r=e.getProp("name")[0].getRawValue().toLowerCase(),n=t.functions.get(r);if(null==n)throw new Error(`Function '${r}' does not exist!`);return n(e.getProp("arg")[0].reduce(t))}abs(e,t){return Math.abs(e.getProp("value")[0].reduce(t))}pow(e,t){return e.getProp("lhs")[0].reduce(t)**e.getProp("rhs")[0].reduce(t)}multdiv(e,t){return"/"===e.getProp("op")[0].getRawValue()?e.getProp("lhs")[0].reduce(t)/e.getProp("rhs")[0].reduce(t):e.getProp("lhs")[0].reduce(t)*e.getProp("rhs")[0].reduce(t)}addsub(e,t){return"-"===e.getProp("op")[0].getRawValue()?e.getProp("lhs")[0].reduce(t)-e.getProp("rhs")[0].reduce(t):e.getProp("lhs")[0].reduce(t)+e.getProp("rhs")[0].reduce(t)}assignment(e,t){const r=e.getProp("name")[0].getRawValue().toLowerCase();return t.variables.set(r,e.getProp("value")[0].reduce(t)),t.variables.get(r)}constructor(){__runInitializers(this,g)}}})();var Calculator;!function(e){const t=new Parser(new CalculatorGrammar);e.evaluate=function(e,r){const n=new Map(Object.entries(Object.assign(r,{pi:Math.PI,e:Math.E})));return{value:+t.parse(e,{variables:n,functions:new Map(Object.entries({sin:Math.sin,cos:Math.cos,tan:Math.tan,sqrt:Math.sqrt}))}),variables:n}}}(Calculator||(Calculator={})),console.log("ASTER Calculator Demo"),async function(){let e=new Map;process.stdout.write("> ");for await(const t of(0,node_readline_1.createInterface)({input:process.stdin})){if("q"===t)return;if(t.trim())try{const r=Calculator.evaluate(t,Object.fromEntries(e.entries()));e=r.variables,console.log(r.value)}catch(e){console.error(e)}process.stdout.write("> ")}}();